# 选择排序:
# 时间复杂度O(n²)
# 空间复杂度O(1)
#
# 选择排序是从第一位开始确定最大或最小的数，保证前面的数都是有序的，且都比后面的数小或大。
#
# 思路分析：
# 1.第一个跟后面的所有数相比，如果小于（或小于）第一个数的时候，暂存较小数的下标，第一趟结束后，将第一个数，与暂存的那个最小数进行交换，第一个数就是最小（或最大的数）
# 2.下标移到第二位，第二个数跟后面的所有数相比，一趟下来，确定第二小（或第二大）的数
# 3.重复以上步骤
# 4.直到指针移到倒数第二位，确定倒数第二小（或倒数第二大）的数，那么最后一位也就确定了，排序完成。

def selection_sort(arr):
    for i in range(len(arr) - 1):
        index = i
        for j in range(i + 1, len(arr)):
            if arr[index] > arr[j]:
                index = j
        if index > 0:
            arr[index], arr[i] = arr[i], arr[index]
        print(arr)  # 这里打印看变化
    print("*" * 10 + "结果：" + "*" * 10)
    print(arr)


A = [5, 2, 4, 6, 1, 3]

# 执行
selection_sort(A)
